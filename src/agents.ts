import { readFile, readdir, writeFile, mkdir } from "node:fs/promises";
import { existsSync } from "node:fs";
import { join, relative, resolve } from "node:path";

const ROOT_AGENTS_FILE = "AGENTS.md";
const LIFFY_ROOT = "liffy";
const LIFFY_AGENTS_FILE = "AGENTS.md";
const LIFFY_STATE_FILE = ".liffy.json";
const SECTION_MARKER = "<!-- liffy:start -->";
const SECTION_END_MARKER = "<!-- liffy:end -->";

type DomainEntry = {
	name: string;
	indexPath: string;
	source?: string;
};

type LiffyState = {
	notices?: {
		tsconfigExclude?: boolean;
		gitignore?: boolean;
	};
};

function getRootSectionContent(): string {
	return `${SECTION_MARKER}

## Liffy Output

Split leaves generated by liffy live under \`liffy/\`.
See \`liffy/AGENTS.md\` for the manifest and usage.

${SECTION_END_MARKER}`;
}

export function getRootAgentsSnippet(): string {
	return getRootSectionContent();
}

function extractSection(content: string): string | null {
	const startIdx = content.indexOf(SECTION_MARKER);
	const endIdx = content.indexOf(SECTION_END_MARKER);
	if (startIdx === -1 || endIdx === -1) return null;
	return content.slice(startIdx, endIdx + SECTION_END_MARKER.length);
}

async function readLiffyState(liffyRoot: string): Promise<LiffyState> {
	const statePath = join(liffyRoot, LIFFY_STATE_FILE);
	if (!existsSync(statePath)) {
		return {};
	}
	try {
		const raw = await readFile(statePath, "utf-8");
		const parsed = JSON.parse(raw);
		if (!parsed || typeof parsed !== "object") {
			return {};
		}
		return parsed as LiffyState;
	} catch {
		return {};
	}
}

async function writeLiffyState(
	liffyRoot: string,
	state: LiffyState,
): Promise<void> {
	const statePath = join(liffyRoot, LIFFY_STATE_FILE);
	await writeFile(statePath, `${JSON.stringify(state, null, 2)}\n`, "utf-8");
}

async function hasTsconfigExclude(cwd: string): Promise<boolean> {
	const tsconfigPath = join(cwd, "tsconfig.json");
	if (!existsSync(tsconfigPath)) {
		return false;
	}
	try {
		const raw = await readFile(tsconfigPath, "utf-8");
		return raw.includes("liffy");
	} catch {
		return false;
	}
}

function hasGitignoreLiffy(content: string): boolean {
	for (const line of content.split(/\r?\n/)) {
		const trimmed = line.trim();
		if (!trimmed || trimmed.startsWith("#")) {
			continue;
		}
		if (
			trimmed === "liffy" ||
			trimmed === "liffy/" ||
			trimmed.startsWith("liffy/")
		) {
			return true;
		}
	}
	return false;
}

async function hasGitignoreEntry(cwd: string): Promise<boolean> {
	const gitignorePath = join(cwd, ".gitignore");
	if (!existsSync(gitignorePath)) {
		return false;
	}
	try {
		const raw = await readFile(gitignorePath, "utf-8");
		return hasGitignoreLiffy(raw);
	} catch {
		return false;
	}
}

async function listDomains(liffyRoot: string): Promise<DomainEntry[]> {
	if (!existsSync(liffyRoot)) {
		return [];
	}

	const entries = await readdir(liffyRoot, { withFileTypes: true });
	const domains: DomainEntry[] = [];

	for (const entry of entries) {
		if (!entry.isDirectory()) continue;
		const indexPath = join(liffyRoot, entry.name, "index.json");
		if (!existsSync(indexPath)) continue;

		let name = entry.name;
		let source: string | undefined;
		try {
			const raw = await readFile(indexPath, "utf-8");
			const parsed = JSON.parse(raw) as { name?: string; source?: string };
			if (typeof parsed.name === "string" && parsed.name.trim()) {
				name = parsed.name.trim();
			}
			if (typeof parsed.source === "string" && parsed.source.trim()) {
				source = parsed.source.trim();
			}
		} catch {
			// Ignore invalid index.json and fall back to directory name.
		}

		domains.push({
			name,
			indexPath: `${LIFFY_ROOT}/${entry.name}/index.json`,
			source,
		});
	}

	return domains.sort((a, b) => a.name.localeCompare(b.name, "en"));
}

function renderLiffyAgents(domains: DomainEntry[]): string {
	const lines: string[] = [
		"# liffy/AGENTS.md",
		"",
		"`liffy/` contains split leaves for LLM context. Each domain lives in",
		"`liffy/<domain>/` and has an `index.json` you can navigate.",
		"",
		"## Quick usage",
		"",
		"- `rg -n \"routing\" liffy/nextjs.org`",
		"- `jq -r '.. | .path? // empty' liffy/nextjs.org/index.json`",
		"",
		"## Domains",
		"",
	];

	if (domains.length === 0) {
		lines.push("- (none yet)");
	} else {
		for (const domain of domains) {
			const parts = [`- ${domain.name} (index: \`${domain.indexPath}\`)`];
			if (domain.source) {
				parts.push(`source: ${domain.source}`);
			}
			lines.push(parts.join(", "));
		}
	}

	lines.push("", "Generated by liffy. Manual edits may be overwritten.", "");
	return lines.join("\n");
}

export function resolveLiffyRoot(
	outputDir: string,
	cwd: string = process.cwd(),
): string | null {
	const liffyRoot = resolve(cwd, LIFFY_ROOT);
	const resolvedOutput = resolve(cwd, outputDir);
	const rel = relative(liffyRoot, resolvedOutput);
	if (rel === "" || !rel.startsWith("..")) {
		return liffyRoot;
	}
	return null;
}

export async function ensureRootAgentsSnippet(
	cwd: string = process.cwd(),
): Promise<boolean> {
	const agentsPath = join(cwd, ROOT_AGENTS_FILE);
	const newSection = getRootSectionContent();

	if (existsSync(agentsPath)) {
		const content = await readFile(agentsPath, "utf-8");
		if (content.includes(SECTION_MARKER)) {
			const existingSection = extractSection(content);
			if (existingSection === newSection) {
				return false;
			}
			const startIdx = content.indexOf(SECTION_MARKER);
			const endIdx = content.indexOf(SECTION_END_MARKER);
			const before = content.slice(0, startIdx);
			const after = content.slice(endIdx + SECTION_END_MARKER.length);
			await writeFile(agentsPath, before + newSection + after, "utf-8");
			return true;
		}

		let newContent = content;
		if (newContent.length > 0 && !newContent.endsWith("\n")) {
			newContent += "\n";
		}
		newContent += "\n" + newSection;
		await writeFile(agentsPath, newContent, "utf-8");
		return true;
	}

	const content = `# AGENTS.md

Instructions for AI coding agents working with this codebase.

${newSection}
`;
	await writeFile(agentsPath, content, "utf-8");
	return true;
}

export async function ensureLiffyAgents(
	liffyRoot: string,
): Promise<boolean> {
	await mkdir(liffyRoot, { recursive: true });
	const agentsPath = join(liffyRoot, LIFFY_AGENTS_FILE);
	const domains = await listDomains(liffyRoot);
	const content = renderLiffyAgents(domains);

	if (existsSync(agentsPath)) {
		const existing = await readFile(agentsPath, "utf-8");
		if (existing === content) {
			return false;
		}
	}

	await writeFile(agentsPath, content, "utf-8");
	return true;
}

export async function maybeGetFirstRunHints(
	liffyRoot: string,
	cwd: string = process.cwd(),
): Promise<string[]> {
	const hints: string[] = [];
	const state = await readLiffyState(liffyRoot);
	const notices = { ...state.notices };
	let dirty = false;

	if (!notices.tsconfigExclude) {
		const tsconfigPath = join(cwd, "tsconfig.json");
		if (existsSync(tsconfigPath)) {
			const hasExclude = await hasTsconfigExclude(cwd);
			if (!hasExclude) {
				hints.push('Update tsconfig.json exclude to include "liffy"');
				hints.push("Example snippet:");
				hints.push("{");
				hints.push('  "exclude": ["liffy", "node_modules"]');
				hints.push("}");
			}
			notices.tsconfigExclude = true;
			dirty = true;
		}
	}

	if (!notices.gitignore) {
		const gitignorePath = join(cwd, ".gitignore");
		if (existsSync(gitignorePath)) {
			const hasIgnore = await hasGitignoreEntry(cwd);
			if (!hasIgnore) {
				if (hints.length > 0) {
					hints.push("");
				}
				hints.push('Add "liffy/" to .gitignore if output is generated');
				hints.push("Run:");
				hints.push('echo "liffy/" >> .gitignore');
			}
			notices.gitignore = true;
			dirty = true;
		}
	}

	if (dirty) {
		state.notices = notices;
		await writeLiffyState(liffyRoot, state);
	}
	return hints;
}
